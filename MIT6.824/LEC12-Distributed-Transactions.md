# 话题
 distributed transactions = concurrency control + atomic commit
  - 大量的数据分布在多个服务器上面，操作通常涉及到多次读取和写入
  - 想对代码编写者隐藏分布式的复杂性
# 事务示例
- x=10、y=10是银行数据库中两个账户的余额，x和y在不同的服务器上（可能是不同的银行）
- T1、T2都是事务，T1代表x转1元给y，T2代表审计钱的总额有没有对
![[Pasted image 20220403085535.png]]
# 事务的正确性
通常被称为ACID
- Atomic（原子性）：在遇上故障的情况下，要么全部执行要么全部不执行
- Consistent（一致性）：数据库通常会让应用程序声明一些不变量（比如上面的x和y账户资金总和）
- Isolated（隔离性）：事务之间不能相互影响（比如看到另外一个事务正在修改的值），也称serializable
- Durable（持久化）：committed write是持久的
# serializable
- 对于上面的例子，执行事务的顺序可能是T1、T2或者T2、T1，这两个结果分别是
	```
	T1、T2 : x=11 y=9 "11,9" 
	T2、T1 : x=11 y=9 "10,10"
	```
	这两个执行顺序都是serializable的（存在一种串行执行的顺序，事务并发执行产生的结果得是串行执行的结果集内）
- 如果T1的操作在T2两个get()之间运行，则T2结果是`"10,9"
	![[Pasted image 20220404084213.png]]
	T2在T1两个add()之间执行，T2结果是`"11,10"`
	并发执行事务产生的结果可能会正常，但是上面两种执行顺序都是不合法，因为结果不在合法的范围内（"11,9"和"10,10"）
- serializable模型简单，编写复杂事务时候能够正确去执行事务；如果事务执行的时候修改的是不同的数据对象，那么在该模型下会真正的并行执行事务，使用数据分片不同数据在不同的服务器上面运行
# abort事务
事务在执行一半时候可能会中止，这种叫abort，会取消任何记录的修改
- 事务可能会自动abort，比如查询到账户不存在，或者余额小于0
- 系统可能会强制abort，例如事务执行的时候遇到死锁，需要abort一些事务破坏死锁
- 服务器故障导致abort
# 并发控制-Isolated
- pessimistic（悲观锁）：使用前锁定数据、锁冲突导致延迟
- optimistic（乐观锁）：不加锁修改数据，commit的时候检查写/读是否满足serializable，不满足则重试，称为Optimistic Concurrency Control (OCC)
- 冲突频繁，悲观锁会更快，反之乐观锁
# 悲观锁
- Two-phase locking(2PL)是实现serializable的一种方式
	- 在对任何数据进行读取或者写入之前，必须先去获取该数据对应的锁
	- 直到事务被commit或者abort后，才能释放掉所获得的锁
	- 如果修改完数据就释放锁（没有等事务完全执行完成），除了会出现并发情况下值不同步的问题外，还可能出现幻读现象：T1执行add(x,1)后释放锁，T2就可能获得锁并打印出x的值然后释放锁，接着T1获得锁，但是abort了，因为可能不存在y这个账户，add(y,-1)失败了，这时候因为原子性就会回滚，x的值就不会+1，所以T2会看到一个不应该存在的值。
- 2PL可能会产生死锁
	```
	T1      T2
  get(x)  get(y)
  get(y)  get(x)
	```
	如果锁是行锁的话，T1先获得x的锁，T2接着或者y的锁，然后T1继续执行想要获得y的锁得等待T2执行完成，T2继续执行想要获得x的锁得等待T1执行完成。
