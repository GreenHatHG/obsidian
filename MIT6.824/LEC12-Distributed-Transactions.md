# 话题
 distributed transactions = concurrency control + atomic commit
  - 大量的数据分布在多个服务器上面，操作通常涉及到多次读取和写入
  - 想对代码编写者隐藏分布式的复杂性
# 事务示例
- x=10、y=10是银行数据库中两个账户的余额，x和y在不同的服务器上（可能是不同的银行）
- T1、T2都是事务，T1代表x转1元给y，T2代表审计钱的总额有没有对
![[Pasted image 20220403085535.png]]
# 事务的正确性
通常被称为ACID
- Atomic（原子性）：在遇上故障的情况下，要么全部执行要么全部不执行
- Consistent（一致性）：数据库通常会让应用程序声明一些不变量（比如上面的x和y账户资金总和）
- Isolated（隔离性）：事务之间不能相互影响（比如看到另外一个事务正在修改的值），也称serializable
- Durable（持久化）：committed write是持久的
# serializable
- 对于上面的例子，执行事务的顺序可能是T1、T2或者T2、T1，这两个结果分别是
	```
	T1、T2 : x=11 y=9 "11,9" 
	T2、T1 : x=11 y=9 "10,10"
	```
	这两个执行顺序都是serializable的（存在一种串行执行的顺序，事务并发执行产生的结果得是串行执行的结果集内）
- 如果T1的操作在T2两个get()之间运行，则T2结果是`"10,9"
	![[Pasted image 20220404084213.png]]
	T2在T1两个add()之间执行，T2结果是`"11,10"`
	并发执行事务产生的结果可能会正常，但是上面两种执行顺序都是不合法，因为结果不在合法的范围内（"11,9"和"10,10"）
- serializable模型简单，编写复杂事务时候能够正确去执行事务；如果事务执行的时候修改的是不同的数据对象，那么在该模型下会真正的并行执行事务，使用数据分片不同数据在不同的服务器上面运行
# abort事务
事务在执行一半时候可能会中止，这种叫abort，会取消任何记录的修改
- 事务可能会自动abort，比如查询到账户不存在，或者余额小于0
- 系统可能会强制abort，例如事务执行的时候遇到死锁，需要abort一些事务破坏死锁
- 服务器故障导致abort
# 并发控制-Isolated
- pessimistic（悲观锁）：使用前锁定数据、锁冲突导致延迟
- optimistic（乐观锁）：不加锁修改数据，commit的时候检查写/读是否满足serializable，不满足则重试，称为Optimistic Concurrency Control (OCC)
- 冲突频繁，悲观锁会更快，反之乐观锁
# 悲观锁
- Two-phase locking(2PL)是实现serializable的一种方式
	- 在对任何数据进行读取或者写入之前，必须先去获取该数据对应的锁
	- 直到事务被commit或者abort后，才能释放掉所获得的锁
	- 如果修改完数据就释放锁（没有等事务完全执行完成），除了会出现并发情况下值不同步的问题外，还可能出现幻读现象：T1执行add(x,1)后释放锁，T2就可能获得锁并打印出x的值然后释放锁，接着T1获得锁，但是abort了，因为可能不存在y这个账户，add(y,-1)失败了，这时候因为原子性就会回滚，x的值就不会+1，所以T2会看到一个不应该存在的值。
- 2PL可能会产生死锁，需要添加机制去解决这个（检测或者是锁定超时）
	```
	T1      T2
  get(x)  get(y)
  get(y)  get(x)
	```
	如果锁是行锁的话，T1先获得x的锁，T2接着或者y的锁，然后T1继续执行想要获得y的锁得等待T2执行完成，T2继续执行想要获得x的锁得等待T1执行完成。
# 分布式事务如何应对故障
假设上面的例子中x和y都位于不同的服务器
x已经+1，但刚好执行y的时候就崩溃了
x已经+1，但是轮到y的时候发现账户不存在
想要解决上面的问题就得实现原子性，要么全部执行要么全部不执行，挑战在于如何实现以及对性能的影响。
# two-phase commit protocol(2PC)
- 用于分布式数据库处理多服务器事务
- 数据分片（shard）存在于多个服务器上面，事务在transaction coordinator(tc)上运行
- 每次读/写，TC都会发送RPC到相关的分片服务器（shard server）。shard server称为participant，每个分片服务器管理着对应数据的锁
- 可能会有很多并发事务，很多TC。TC为每个事务分配一个唯一事务ID(TID)，每个RPC消息、table entry都有TID。
  ![[Pasted image 20220404155519.png]]
1. client给TC发送执行事务请求，并等待响应
2. TC给A发送get请求，给B发送put请求，并收到各自的回复（锁住数据后暂时修改，commit后才会持久化）
3. TC给A个B发送prepare消息，A和B会去检查是否能够完成这个事务中的操作，TC会等待每个事务参与者的回复（Yes/No）
4. 如果A和B都回复Yes，则TC向A和B发送commit消息。
5. 收到TC的commit消息后，A/B commit并释放事务对数据的锁，A/B回复ACK消息
6. TC回复给client
- 如果A或B回复No（缺了一条记录或者发生了故障等），则TC发送abort消息，回滚数据
- 每个participant都有一张lock表，将锁与该事务所操作的数据对象关联起来。
# B crash并reboot会发生什么
- B在crash之前已经给TC发送了Yes，假设此时A也回复了Yes，TC给A和B发送commit消息，那么A可能已经收到并commit了。所以B在收到prepara消息回复Yes之前，需要将所作的修改（生成的新值、lock列表）持久化到磁盘，即使在重启后，也能够commit或者不commit。
- B重启后会查看日志发现有